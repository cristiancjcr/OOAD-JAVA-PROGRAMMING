âœ… Ce este `OCP` â€“ pe scurt
O clasÄƒ sau modul trebuie sÄƒ fie :

- Deschis pentru extindere (adicÄƒ poÈ›i adÄƒuga comportament nou)
- Ãnchis pentru modificare (nu trebuie sÄƒ modifici codul existent)



ğŸ¯ Unde È™i pentru ce Ã®l folosim
ğŸ§± Folosim `OCP` Ã®n situaÈ›ii unde comportamentul se poate schimba sau extinde Ã®n viitor, de exemplu :

- Sisteme cu reguli de business variabile (reduceri, taxe, comisioane)
- Calculatoare de preÈ›, de scoruri, de bonusuri
- Sisteme de platÄƒ cu mai multe metode (card, PayPal, crypto etc.)
- Parsere pentru diferite tipuri de fiÈ™iere (JSON, XML, CSV)
- Ãn framework-uri (Spring, Hibernate) unde extensibilitatea e criticÄƒ

â¡ï¸ Scopul e sÄƒ evitÄƒm efectul de â€œcascadÄƒâ€ : cÃ¢nd adaugi o funcÈ›ie nouÄƒ È™i trebuie sÄƒ modifici zeci de locuri.



âš”ï¸ De ce e mai bun decÃ¢t "if-uri peste if-uri"

FÄƒrÄƒ `OCP` :
- Ai un if/else mare Ã®n mijlocul codului
- Codul devine greu de citit È™i testat
- AdÄƒugarea unui nou comportament implicÄƒ modificÄƒri directe Ã®n logica existentÄƒ (risc de bug-uri)

Cu `OCP` :
- FoloseÈ™ti interfeÈ›e + polimorfism pentru a injecta comportamente
- CÃ¢nd adaugi ceva nou, creezi o clasÄƒ nouÄƒ, nu modifici clasele existente
- Codul e mai sigur, mai clar È™i testabil modular



âš¡ Avantaje practice

âœ… UÈ™or de extins fÄƒrÄƒ riscuri
âœ… Cod clar, fÄƒrÄƒ switch/if greu de urmÄƒrit
âœ… EvitÄƒm "god classes" â€“ clase uriaÈ™e care fac de toate
âœ… Ideal Ã®n echipe mari, unde fiecare dezvoltator poate lucra pe o clasÄƒ fÄƒrÄƒ sÄƒ afecteze altele



ğŸ§  Exemple din viaÈ›a realÄƒ

Adaugi un nou tip de reducere Ã®n magazin â†’ creezi o nouÄƒ clasÄƒ
Vrei un nou export Ã®n format Excel â†’ creezi o nouÄƒ implementare
Adaugi un nou filtru pe o listÄƒ â†’ doar implementezi o interfaÈ›Äƒ
