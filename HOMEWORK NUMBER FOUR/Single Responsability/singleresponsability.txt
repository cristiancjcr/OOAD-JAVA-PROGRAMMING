DefiniÈ›ie simplÄƒ :
O clasÄƒ ar trebui sÄƒ aibÄƒ un singur motiv sÄƒ se schimbe.
Asta Ã®nseamnÄƒ cÄƒ o clasÄƒ ar trebui sÄƒ aibÄƒ o singurÄƒ responsabilitate clar definitÄƒ.



âœ… De ce e important ?
DacÄƒ o clasÄƒ face prea multe lucruri, atunci :

- Devine greu de testat.
- E greu de Ã®nÈ›eles.
- E fragilÄƒ: o micÄƒ modificare poate strica alte funcÈ›ionalitÄƒÈ›i.
- Devine un "god object" â€“ greu de Ã®ntreÈ›inut.



ğŸ¯ CÃ¢nd e recomandabil sÄƒ aplici `SRP` ?
- CÃ¢nd o clasÄƒ Ã®ncepe sÄƒ creascÄƒ prea mult.
- CÃ¢nd vezi metode care â€nu au legÄƒturÄƒ una cu altaâ€.
- CÃ¢nd ai modificÄƒri frecvente Ã®n aceeaÈ™i clasÄƒ pentru motive diferite (afiÈ™are, logicÄƒ, salvare etc).
- Ãn aplicaÈ›ii enterprise â€“ cum e Ã®n `Spring` â€“ unde fiecare componentÄƒ ar trebui sÄƒ fie specializatÄƒ (ex: Controller, Service, Repository).



ğŸ” "Un motiv sÄƒ se schimbe" â‰  o singurÄƒ metodÄƒ
MultÄƒ lume crede cÄƒ dacÄƒ o clasÄƒ are o singurÄƒ metodÄƒ, deja respectÄƒ `SRP`. Dar `SRP` nu se referÄƒ la numÄƒrul metodelor, ci la numÄƒrul motivelor pentru care ar trebui sÄƒ se modifice codul.

ğŸ§  De exemplu:
DacÄƒ modifici o clasÄƒ pentru a schimba formatul de printare È™i altÄƒ datÄƒ pentru a schimba logica de calcul â€” atunci are 2 responsabilitÄƒÈ›i È™i `SRP` e Ã®ncÄƒlcat.



ğŸ§± AjutÄƒ la Testare Unitara
DacÄƒ o clasÄƒ face un singur lucru, devine :

- uÈ™or de testat
- uÈ™or de izolat
- uÈ™or de "mock-uit" Ã®n testele altor clase



ğŸ§  Cum combini `SRP` cu alte principii ?
`SRP` se Ã®nÈ›elege foarte bine cu alte principii din SOLID:

- cu `Open / Closed Principle` : fiind separate, clasele pot fi extinse fÄƒrÄƒ modificare.
- cu `Dependency Inversion` : fiecare responsabilitate devine o dependenÈ›Äƒ injectabilÄƒ.
- cu `Interface Segregation` : fiecare responsabilitate Ã®È™i poate avea propria interfaÈ›Äƒ.
